################## ИМПОРТЫ ##################
import os, time, json, psycopg, math
from contextlib import contextmanager
from typing import Optional, Dict, Any, List, Union
from psycopg.rows import dict_row
from psycopg import sql
from psycopg.errors import OperationalError, UndefinedTable, SyntaxError
from fastapi import HTTPException
from datetime import datetime, timezone

PG_DB        = os.getenv("PG_DB", "alldata")
PG_HOST      = os.getenv("PG_HOST", "localhost")
PG_PORT      = os.getenv("PG_PORT", "5432")
PG_USER      = os.getenv("PG_USER", "postgres")
PG_PASSWORD  = os.getenv("PG_PASSWORD", "1234")

TARGET_DSN = (
    f"dbname={PG_DB} "
    f"user={PG_USER} " 
    f"password={PG_PASSWORD} "
    f"host={PG_HOST} "
    f"port={PG_PORT} "
)

ADMIN_DSN = (
    f"dbname=postgres "
    f"user={PG_USER} "
    f"password={PG_PASSWORD} "
    f"host={PG_HOST} "
    f"port={PG_PORT} "
)

################## Подключение к DB ##################
@contextmanager
def get_conn(dsn: str = TARGET_DSN):
    with psycopg.connect(dsn, row_factory=dict_row) as conn:
        yield conn

def init_db():
    ensure_database_exists(PG_DB)
    with _connect_with_retry(TARGET_DSN) as conn:
        with conn.cursor() as cur:
            ddl = """
            CREATE TABLE IF NOT EXISTS users (
                id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                name          TEXT NOT NULL,
                surname       TEXT NOT NULL,
                position      TEXT,
                phone         TEXT,
                email         TEXT UNIQUE NOT NULL,          
                company       TEXT,
                address       TEXT,
                notes         TEXT,
                avatar_path   TEXT,
                password      TEXT NOT NULL,                
                created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
                updated_at    TIMESTAMPTZ NOT NULL DEFAULT now()
            );

            CREATE TABLE IF NOT EXISTS files (
                id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id      BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                filename     TEXT NOT NULL,
                mime         TEXT,
                size_bytes   BIGINT,
                file_data    BYTEA NOT NULL, 
                created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
            );

            CREATE TABLE IF NOT EXISTS declarations (
                id                BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id           BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                title             TEXT NOT NULL,
                goods_description TEXT,
                tnved_code        TEXT,
                attached_file_id  BIGINT REFERENCES files(id) ON DELETE SET NULL,
                meta_json         JSONB,
                created_at        TIMESTAMPTZ NOT NULL DEFAULT now()
            );

            CREATE TABLE IF NOT EXISTS user_profile (
                user_id      BIGINT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
                first_name   TEXT,
                last_name    TEXT,
                position     TEXT,
                phone        TEXT,
                email        TEXT,
                company      TEXT,
                address      TEXT,
                notes        TEXT,
                avatar_path  TEXT,
                created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
                updated_at   TIMESTAMPTZ NOT NULL DEFAULT now()
            );
            CREATE TABLE IF NOT EXISTS declaration_files (
                id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                declaration_id  BIGINT NOT NULL REFERENCES declarations(id) ON DELETE CASCADE,
                file_id         BIGINT NOT NULL REFERENCES files(id) ON DELETE CASCADE,
                doc_key         TEXT NOT NULL,  -- 'invoice', 'packing', 'contract', ...
                created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
            );
            CREATE TABLE IF NOT EXISTS jobs (
                id          BIGSERIAL PRIMARY KEY,
                status      TEXT NOT NULL DEFAULT 'queued',  -- queued | processing | done | error
                decl_id     BIGINT NOT NULL,
                file_id     BIGINT NOT NULL,
                doc_key     TEXT NOT NULL,
                attempts    INT NOT NULL DEFAULT 0,
                error_text  TEXT,
                result_json JSONB,
                created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
                started_at  TIMESTAMPTZ,
                finished_at TIMESTAMPTZ
            );
            
            CREATE TABLE IF NOT EXISTS tnved_requests (
                id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id       BIGINT REFERENCES users(id) ON DELETE CASCADE,

                -- что пользователь отправил (текст/описание товара, параметры)
                query_text    TEXT,
                input_json    JSONB,

                -- результат работы (ответ/подбор кода)
                result_json   JSONB,
                status        TEXT NOT NULL DEFAULT 'done',  -- done | error
                error_text    TEXT,

                credits_spent INT NOT NULL DEFAULT 1,

                -- доп.метрики, если хочешь
                model         TEXT,
                latency_ms    INT,

                created_at    TIMESTAMPTZ NOT NULL DEFAULT now()
                );

            CREATE INDEX IF NOT EXISTS idx_tnved_requests_user_id_created
            ON tnved_requests(user_id, created_at DESC);

            CREATE TABLE IF NOT EXISTS tariff_plans (
                id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                code         TEXT UNIQUE NOT NULL,  -- 't1', 't10', 't30'
                title        TEXT NOT NULL,
                price_rub    INT NOT NULL CHECK (price_rub >= 0), -- 50 / 400 / 1000
                credits      INT NOT NULL CHECK (credits > 0),    -- 1 / 10 / 30
                is_active    BOOLEAN NOT NULL DEFAULT TRUE,
                created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
                );
                
                -- один раз при инициализации/миграции:
                INSERT INTO tariff_plans(code, title, price_rub, credits)
                VALUES
                ('t1',  '1 запрос',        50,   1),
                ('t10', 'Пакет 10 запросов', 400, 10),
                ('t30', 'Пакет 30 запросов', 1000, 30)
                ON CONFLICT (code) DO NOTHING;

            CREATE TABLE IF NOT EXISTS user_credits_balance (
                user_id           BIGINT PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
                credits_remaining INT NOT NULL DEFAULT 0 CHECK (credits_remaining >= 0),
                updated_at        TIMESTAMPTZ NOT NULL DEFAULT now()
                );


            CREATE TABLE IF NOT EXISTS credits_ledger (
                id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id     BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                delta       INT NOT NULL, -- +10 при покупке, -1 при запросе
                reason      TEXT NOT NULL, -- purchase | use | refund | admin_adjust
                ref_type    TEXT,          -- 'payment' | 'request' | ...
                ref_id      BIGINT,
                meta_json   JSONB,
                created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
                );

            CREATE TABLE IF NOT EXISTS payments (
                id                   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                user_id              BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,

                provider             TEXT NOT NULL DEFAULT 'yookassa',
                provider_payment_id  TEXT UNIQUE,          -- id из YooKassa
                idempotence_key      TEXT UNIQUE,          -- чтобы не создать два платежа

                tariff_plan_id       BIGINT REFERENCES tariff_plans(id) ON DELETE SET NULL,

                amount_value         TEXT NOT NULL,        -- "50.00"
                currency             TEXT NOT NULL DEFAULT 'RUB',

                status               TEXT NOT NULL DEFAULT 'pending', -- pending|waiting_for_capture|succeeded|canceled
                paid_at              TIMESTAMPTZ,
                created_at           TIMESTAMPTZ NOT NULL DEFAULT now(),

                raw_json             JSONB
                );

            CREATE INDEX IF NOT EXISTS idx_payments_user_id_created
            ON payments(user_id, created_at DESC);
            CREATE INDEX IF NOT EXISTS idx_payments_status
            ON payments(status);

            CREATE INDEX IF NOT EXISTS idx_credits_ledger_user_id_created
            ON credits_ledger(user_id, created_at DESC);

            -- функция обновления updated_at
            CREATE OR REPLACE FUNCTION set_updated_at()
            RETURNS trigger AS $$
            BEGIN
                NEW.updated_at := now();
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;

            DO $$
            BEGIN
                IF NOT EXISTS (
                    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_users_updated_at'
                ) THEN
                    CREATE TRIGGER trg_users_updated_at
                    BEFORE UPDATE ON users
                    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
                END IF;

                IF NOT EXISTS (
                    SELECT 1 FROM pg_trigger WHERE tgname = 'trg_user_profile_updated_at'
                ) THEN
                    CREATE TRIGGER trg_user_profile_updated_at
                    BEFORE UPDATE ON user_profile
                    FOR EACH ROW EXECUTE FUNCTION set_updated_at();
                END IF;
            END$$;

            CREATE INDEX IF NOT EXISTS idx_files_user_id         ON files(user_id);
            CREATE INDEX IF NOT EXISTS idx_declarations_user_id  ON declarations(user_id);
            CREATE INDEX IF NOT EXISTS idx_declarations_file_id  ON declarations(attached_file_id);
            CREATE INDEX IF NOT EXISTS idx_users_email           ON users(email);
            CREATE INDEX IF NOT EXISTS idx_decl_files_decl_id ON declaration_files(declaration_id);
            CREATE INDEX IF NOT EXISTS idx_decl_files_file_id ON declaration_files(file_id);
            """
            with get_conn(TARGET_DSN) as conn:
                with conn.cursor() as cur:
                    cur.execute(ddl)
                conn.commit()

def ensure_database_exists(dbname: str = PG_DB):
    with psycopg.connect(ADMIN_DSN) as conn:
        conn.autocommit = True  
        with conn.cursor() as cur:
            cur.execute("SELECT 1 FROM pg_database WHERE datname = %s", (dbname,))
            if not cur.fetchone():
                cur.execute(sql.SQL("CREATE DATABASE {}").format(sql.Identifier(dbname)))

def _connect_with_retry(dsn: str, retries: int = 5, delay_sec: float = 0.2):
    last_ex = None
    for _ in range(retries):
        try:
            return psycopg.connect(dsn, row_factory=dict_row)
        except OperationalError as ex:
            last_ex = ex
            time.sleep(delay_sec)
    raise last_ex

################## Пользователи ##################
def get_user_by_email(email: str) -> Optional[Dict[str, Any]]:
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute("SELECT * FROM users WHERE email = %s", (email,))
        row = cur.fetchone()
        return dict(row) if row else None

def get_user_by_id(user_id: int) -> Optional[Dict[str, Any]]:
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute("SELECT * FROM users WHERE id = %s", (user_id,))
        row = cur.fetchone()
        return dict(row) if row else None

def update_user(user_id: int, **fields):
    allowed = {
        "name","surname","position","phone","email","company","address","notes",
        "avatar_path","password",
        "must_change_password",  # NEW
    }
    sets, vals = [], []
    for k, v in fields.items():
        if k in allowed:
            sets.append(f"{k} = %s")
            vals.append(v)
    if not sets:
        return
    vals.append(user_id)
    q = f"UPDATE users SET {', '.join(sets)} WHERE id = %s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, tuple(vals))
        conn.commit()

def set_user_role(user_id: int, role: str) -> None:
    role = (role or "user").strip().lower()
    allowed = {"user", "declarant", "tamarix", "admin"}
    if role not in allowed:
        raise ValueError(f"Invalid role: {role}")
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute("UPDATE users SET role = %s WHERE id = %s", (role, user_id))
        conn.commit()


def consume_free_credits(user_id: int, amount: int = 1) -> int:
    if amount <= 0:
        u = get_user_by_id(user_id) or {}
        return int(u.get("free_credits_remaining") or 0)

    with get_conn() as conn, conn.cursor() as cur:
        cur.execute("SELECT free_credits_remaining FROM users WHERE id=%s FOR UPDATE", (user_id,))
        row = cur.fetchone()
        if not row:
            raise ValueError("User not found")

        rem = int(row.get("free_credits_remaining") or 0)
        if rem < amount:
            raise HTTPException(402, "Бесплатные запросы закончились")

        cur.execute("UPDATE users SET free_credits_remaining=%s WHERE id=%s", (rem - amount, user_id))
        conn.commit()
        return rem - amount


def create_user(
    name: str,
    surname: str,
    email: str,
    password: str,
    role: str = 'user',
    position: Optional[str] = None,
    phone: Optional[str] = None,
    company: Optional[str] = None,
    address: Optional[str] = None,
    notes: Optional[str] = None,
    avatar_path: Optional[str] = None
) -> int:
    q = """
    INSERT INTO users (name, surname, position, phone, email, company, address, notes, avatar_path, password, role)
    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
    RETURNING id
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (name, surname, position, phone, email, company, address, notes, avatar_path, password, role))
        new_id = cur.fetchone()["id"]
        conn.commit()
        return int(new_id)


def set_user_must_change_password(user_id: int, flag: bool) -> None:
    update_user(int(user_id), must_change_password=bool(flag))

def set_user_password_and_force_change(user_id: int, password_hash: str) -> None:
    update_user(int(user_id), password=password_hash, must_change_password=True)

def clear_user_force_change(user_id: int) -> None:
    update_user(int(user_id), must_change_password=False)

def set_user_password_and_flag(user_id: int, password_hash: str, must_change_password: bool):
    q = """
    UPDATE users
    SET password = %s,
        must_change_password = %s,
        updated_at = now()
    WHERE id = %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (password_hash, must_change_password, user_id))
        conn.commit()


################## Файлы ##################
def add_file(user_id: int, filename: str, mime: str, file_bytes: bytes) -> int:
    q = """
    INSERT INTO files(user_id, filename, mime, size_bytes, file_data)
    VALUES (%s, %s, %s, %s, %s)
    RETURNING id
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (user_id, filename, mime, len(file_bytes), psycopg.Binary(file_bytes)))
        file_id = cur.fetchone()["id"]
        conn.commit()
        return int(file_id)
        
def list_files(user_id: int, limit: int = 200) -> List[Dict[str, Any]]:
    q = """
    SELECT id, filename, mime, size_bytes, created_at
    FROM files
    WHERE user_id = %s
    ORDER BY created_at DESC
    LIMIT %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (user_id, limit))
        return [dict(r) for r in cur.fetchall()]

def get_file(file_id: int) -> Optional[Dict[str, Any]]:
    q = """
    SELECT id, user_id, filename, mime, size_bytes, file_data, created_at
    FROM files
    WHERE id = %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (file_id,))
        row = cur.fetchone()
        return dict(row) if row else None

def search_files(user_id: int, query: str, limit: int = 500) -> List[Dict[str, Any]]:
    qsql = """
    SELECT id, filename, mime, size_bytes, created_at
    FROM files
    WHERE user_id = %s
      AND (filename ILIKE %s OR COALESCE(mime,'') ILIKE %s)
    ORDER BY created_at DESC
    LIMIT %s
    """
    like = f"%{query}%"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(qsql, (user_id, like, like, limit))
        return [dict(r) for r in cur.fetchall()]

def delete_file(file_id: int) -> int:
    q = "DELETE FROM files WHERE id=%s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (file_id,))
        affected = cur.rowcount
        conn.commit()
        return affected

def count_file_links(file_id: int) -> int:
    q = "SELECT COUNT(*) AS c FROM declaration_files WHERE file_id=%s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (file_id,))
        row = cur.fetchone()
        return int(row["c"])

def replace_file(declaration_id: int, user_id: int, doc_key: str,
                      filename: str, mime: str, data: bytes) -> int:
    q_select_old = """
        SELECT f.id
        FROM declaration_files df
        JOIN files f ON f.id = df.file_id
        WHERE df.declaration_id = %s AND df.doc_key = %s
    """
    q_delete_old = "DELETE FROM files WHERE id = ANY(%s)"
    q_insert_file = """
        INSERT INTO files (user_id, filename, mime, size_bytes, file_data)
        VALUES (%s, %s, %s, %s, %s)
        RETURNING id
    """
    q_link = """
        INSERT INTO declaration_files (declaration_id, file_id, doc_key)
        VALUES (%s, %s, %s)
    """

    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q_select_old, (declaration_id, doc_key))
        old_ids = [r["id"] for r in cur.fetchall()]
        if old_ids:
            cur.execute(q_delete_old, (old_ids,))
        cur.execute(
            q_insert_file,
            (user_id, filename, mime, len(data), psycopg.Binary(data))
        )
        new_fid = int(cur.fetchone()["id"])
        cur.execute(q_link, (declaration_id, new_fid, doc_key))
        conn.commit()
        return new_fid
    
################## Декларации ##################
def add_declaration(
    user_id: int,
    title: str,
    created_at: Optional[datetime] = None,
    goods_description: Optional[str] = None,
    tnved_code: Optional[str] = None,
    attached_file_id: Optional[int] = None,
    meta_json: Optional[Union[str, dict]] = None
) -> int:
    if isinstance(meta_json, dict):
        meta_json = json.dumps(meta_json, ensure_ascii=False)

    q = """
    INSERT INTO declarations(
        user_id, title, goods_description, tnved_code, attached_file_id, meta_json, created_at
    )
    VALUES (%s, %s, %s, %s, %s, %s::jsonb, COALESCE(%s::timestamptz, now()))
    RETURNING id
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(
            q,
            (user_id, title, goods_description, tnved_code, attached_file_id, meta_json, created_at)
        )
        dec_id = cur.fetchone()["id"]
        conn.commit()
        return int(dec_id)

# def list_declarations(user_id: int, limit: int = 200) -> List[Dict[str, Any]]:
#     q = """
#     SELECT d.id, d.title, d.goods_description, d.tnved_code,
#            d.attached_file_id, d.created_at, f.filename AS file_name
#     FROM declarations d
#     LEFT JOIN files f ON f.id = d.attached_file_id
#     WHERE d.user_id = %s
#     ORDER BY d.created_at DESC
#     LIMIT %s
#     """
#     with get_conn() as conn, conn.cursor() as cur:
#         cur.execute(q, (user_id, limit))
#         return [dict(r) for r in cur.fetchall()]

def list_declarations(user_id: int, limit: int = 200):
    q = """
    SELECT
      d.id,
      d.title,
      d.created_at,
      d.attached_file_id,
      f.filename AS file_name,

      COALESCE((
        SELECT COUNT(*)
        FROM declaration_files df
        WHERE df.declaration_id = d.id
      ), 0) AS files_count,

      COALESCE((
        SELECT ARRAY_AGG(DISTINCT df.doc_key)
        FROM declaration_files df
        WHERE df.declaration_id = d.id
      ), ARRAY[]::text[]) AS doc_keys

    FROM declarations d
    LEFT JOIN files f ON f.id = d.attached_file_id
    WHERE d.user_id = %s
    ORDER BY d.created_at DESC
    LIMIT %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (user_id, limit))
        return [dict(r) for r in cur.fetchall()]



def update_declaration(decl_id: int, **fields) -> None:
    allowed = {"title", "goods_description", "tnved_code", "attached_file_id", "meta_json"}
    sets, vals = [], []
    for k, v in fields.items():
        if k in allowed:
            if k == "meta_json" and isinstance(v, dict):
                sets.append(f"{k} = %s::jsonb")
                vals.append(json.dumps(v, ensure_ascii=False))
            else:
                sets.append(f"{k} = %s")
                vals.append(v)

    if not sets:
        return  # ничего не обновляем

    vals.append(decl_id)
    q = f"UPDATE declarations SET {', '.join(sets)} WHERE id = %s"

    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, tuple(vals))
        conn.commit()

def get_declaration_date(declaration_id: int) -> Optional[str]:
    q = "SELECT to_char(created_at, 'DD.MM.YYYY') AS created_date FROM declarations WHERE id = %s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (declaration_id,))
        row = cur.fetchone()
        return (row or {}).get("created_date")
    
def get_declaration_datetime(declaration_id: int) -> str:
    q = """
        SELECT to_char(created_at, 'YYYY-MM-DD"T"HH24:MI:SS') AS created_date FROM declarations WHERE id = %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (declaration_id,))
        row = cur.fetchone()
        return (row or {}).get("created_date")

    
################## Профиль пользователя ##################
def get_user_profile(user_id: int) -> Optional[Dict[str, Any]]:
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute("SELECT * FROM user_profile WHERE user_id = %s", (user_id,))
        row = cur.fetchone()
        return dict(row) if row else None

def upsert_user_profile(user_id: int, data: Dict[str, Any]) -> None:
    keys = ["first_name","last_name","position","phone","email","company","address","notes","avatar_path"]
    cols = ", ".join(keys)
    placeholders = ", ".join(["%s"] * len(keys))
    vals = [data.get(k) for k in keys]

    q = f"""
    INSERT INTO user_profile (user_id, {cols})
    VALUES (%s, {placeholders})
    ON CONFLICT (user_id)
    DO UPDATE SET
        {", ".join([f"{k} = EXCLUDED.{k}" for k in keys])},
        updated_at = now()
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (user_id, *vals))
        conn.commit()

################## Файлы декларации ##################
def link_file_to_declaration(declaration_id: int, file_id: int, doc_key: str, replace: bool = False) -> int:
    q_insert = """
        INSERT INTO declaration_files (declaration_id, file_id, doc_key)
        VALUES (%s, %s, %s)
        RETURNING id
    """
    q_delete = """
        DELETE FROM declaration_files
        WHERE declaration_id = %s AND doc_key = %s
    """

    with get_conn() as conn, conn.cursor() as cur:
        if replace:
            cur.execute(q_delete, (declaration_id, doc_key))

        cur.execute(q_insert, (declaration_id, file_id, doc_key))
        link_id = cur.fetchone()["id"]
        conn.commit()
        return int(link_id)

def list_declaration_files(declaration_id: int) -> List[Dict[str, Any]]:
    q = """
    SELECT df.id as link_id, df.doc_key, df.created_at,
           f.id as file_id, f.filename, f.mime, f.size_bytes
    FROM declaration_files df
    JOIN files f ON f.id = df.file_id
    WHERE df.declaration_id = %s
    ORDER BY df.created_at DESC
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (declaration_id,))
        return [dict(r) for r in cur.fetchall()]
    
def get_declaration_invoice_json(declaration_id: int) -> Optional[Dict[str, Any]]:
    q = """
    SELECT f.file_data
    FROM declaration_files df
    JOIN files f ON f.id = df.file_id
    WHERE df.declaration_id = %s
      AND df.doc_key = %s
    ORDER BY df.created_at DESC
    LIMIT 1
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (declaration_id, "invoice_json"))
        row = cur.fetchone()
        if not row:
            return None

        blob = row.get("file_data")
        if not blob:
            return None

        try:
            obj = json.loads(blob.decode("utf-8", errors="ignore"))
        except Exception:
            return None

        # ожидаем dict (как твой parsed invoice_json); на всякий случай проверяем
        return obj if isinstance(obj, dict) else None

def save_declaration_invoice_json(declaration_id: int, invoice: Dict[str, Any]) -> None:
    q = """
    SELECT f.id
    FROM declaration_files df
    JOIN files f ON f.id = df.file_id
    WHERE df.declaration_id = %s
      AND df.doc_key = %s
    ORDER BY df.created_at DESC
    LIMIT 1
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (declaration_id, "invoice_json"))
        row = cur.fetchone()
        if not row:
            return

        file_id = row["id"]
        payload = json.dumps(invoice, ensure_ascii=False, indent=2).encode("utf-8")

        cur.execute(
            "UPDATE files SET file_data = %s, size_bytes = %s WHERE id = %s",
            (payload, len(payload), file_id),
        )
        conn.commit()


def unlink_file_from_declaration(declaration_id: int, file_id: int) -> int:
    q = "DELETE FROM declaration_files WHERE declaration_id=%s AND file_id=%s RETURNING id"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (declaration_id, file_id))
        deleted = cur.rowcount
        conn.commit()
        return deleted
    
def get_declaration_user_id(declaration_id: int) -> Optional[int]:
    """
    Вернуть user_id владельца декларации (или None, если декларация не найдена).
    """
    q = "SELECT user_id FROM declarations WHERE id = %s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (declaration_id,))
        row = cur.fetchone()
        return (row or {}).get("user_id")

################## Очередь файлов ##################
def jobs_create(decl_id: int, file_id: int, doc_key: str) -> int:
    q = """INSERT INTO jobs(decl_id, file_id, doc_key, status)
           VALUES (%s,%s,%s,'queued') RETURNING id"""
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (decl_id, file_id, doc_key))
        jid = cur.fetchone()["id"]
        conn.commit()
        return int(jid)

def jobs_get(job_id: int) -> Optional[Dict[str, Any]]:
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute("SELECT * FROM jobs WHERE id=%s", (job_id,))
        row = cur.fetchone()
        return dict(row) if row else None

def jobs_list_by_decl(decl_id: int, limit: int = 200) -> List[Dict[str, Any]]:
    q = """SELECT * FROM jobs WHERE decl_id=%s ORDER BY created_at DESC LIMIT %s"""
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (decl_id, limit))
        return [dict(r) for r in cur.fetchall()]

def jobs_claim_next() -> Optional[Dict[str, Any]]:
    with psycopg.connect(TARGET_DSN, row_factory=dict_row) as c:
        c.autocommit = False
        with c.cursor() as cur:
            row = cur.execute("""
                SELECT * FROM jobs
                WHERE status='queued'
                ORDER BY created_at ASC
                FOR UPDATE SKIP LOCKED
                LIMIT 1
            """).fetchone()
            if not row:
                c.rollback()
                return None
            cur.execute("""
                UPDATE jobs
                   SET status='processing', started_at=now(), attempts=attempts+1
                 WHERE id=%s
            """, (row["id"],))
            c.commit()
            return dict(row)

def jobs_finish_ok(job_id: int, result: Dict[str, Any]) -> None:
    q = """UPDATE jobs SET status='done', result_json=%s, finished_at=now() WHERE id=%s"""
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (json.dumps(result, ensure_ascii=False), job_id))
        conn.commit()

def jobs_finish_err(job_id: int, err: str) -> None:
    q = """UPDATE jobs SET status='error', error_text=%s, finished_at=now() WHERE id=%s"""
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (err[:4000], job_id))
        conn.commit()


################## Изменения в alldata ##################
def get_overrides(decl_id: int) -> Dict[str, Any]:
    q = "SELECT meta_json FROM declarations WHERE id=%s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (decl_id,))
        row = cur.fetchone()
        meta = (row or {}).get("meta_json") or {}
        if isinstance(meta, str):
            try:
                meta = json.loads(meta)
            except Exception:
                meta = {}
        return meta.get("overrides", {})

def save_overrides(decl_id: int, overrides: Dict[str, Any]) -> None:
    q = """
    UPDATE declarations
       SET meta_json = COALESCE(meta_json, '{}'::jsonb)
                       || jsonb_build_object('overrides', %s::jsonb)
     WHERE id = %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (json.dumps(overrides, ensure_ascii=False), decl_id))
        conn.commit()


################## Тарифы / Платежи / Кредиты ##################
def list_active_tariff_plans() -> List[Dict[str, Any]]:
    q = """
    SELECT id, code, title, price_rub, credits
    FROM tariff_plans
    WHERE is_active = TRUE
    ORDER BY price_rub ASC
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q)
        return [dict(r) for r in cur.fetchall()]

def get_tariff_plan_by_code(code: str) -> Optional[Dict[str, Any]]:
    q = """
    SELECT id, code, title, price_rub, credits
    FROM tariff_plans
    WHERE code = %s AND is_active = TRUE
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (code,))
        row = cur.fetchone()
        return dict(row) if row else None

def payments_create_pending(
    *,
    user_id: int,
    tariff_plan_id: int,
    amount_value: str,
    currency: str,
    idempotence_key: str,
    raw_json: Optional[dict] = None,
) -> Dict[str, Any]:
    q = """
    INSERT INTO payments(user_id, tariff_plan_id, amount_value, currency, status, idempotence_key, raw_json)
    VALUES (%s, %s, %s, %s, 'pending', %s, %s::jsonb)
    RETURNING *
    """
    raw = json.dumps(raw_json or {}, ensure_ascii=False)
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (user_id, tariff_plan_id, amount_value, currency, idempotence_key, raw))
        row = cur.fetchone()
        conn.commit()
        return dict(row)

def payments_set_provider_payment_id(payment_id: int, provider_payment_id: str, raw_json: dict) -> None:
    q = """
    UPDATE payments
    SET provider_payment_id = %s,
        raw_json = %s::jsonb
    WHERE id = %s
    """
    raw = json.dumps(raw_json or {}, ensure_ascii=False)
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (provider_payment_id, raw, payment_id))
        conn.commit()

def payments_get_by_id(payment_id: int) -> Optional[Dict[str, Any]]:
    q = "SELECT * FROM payments WHERE id = %s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (payment_id,))
        row = cur.fetchone()
        return dict(row) if row else None

def payments_get_by_id_and_user(payment_id: int, user_id: int) -> Optional[Dict[str, Any]]:
    q = "SELECT * FROM payments WHERE id = %s AND user_id = %s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (payment_id, user_id))
        row = cur.fetchone()
        return dict(row) if row else None

def payments_get_by_provider_payment_id(provider_payment_id: str) -> Optional[Dict[str, Any]]:
    q = "SELECT * FROM payments WHERE provider_payment_id = %s"
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (provider_payment_id,))
        row = cur.fetchone()
        return dict(row) if row else None

def payments_update_status_by_provider_id(
    provider_payment_id: str,
    status: str,
    raw_json: dict,
    paid_at: Optional[datetime] = None,
) -> Optional[Dict[str, Any]]:
    q = """
    UPDATE payments
    SET status = %s,
        paid_at = COALESCE(%s, paid_at),
        raw_json = %s::jsonb
    WHERE provider_payment_id = %s
    RETURNING *
    """
    raw = json.dumps(raw_json or {}, ensure_ascii=False)
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (status, paid_at, raw, provider_payment_id))
        row = cur.fetchone()
        conn.commit()
        return dict(row) if row else None

def credits_apply_purchase(
    *,
    user_id: int,
    payment_id: int,
    credits: int,
    meta: Optional[dict] = None,
    paid_at: Optional[datetime] = None,
) -> None:
    """
    ВАЖНО: period_start = paid_at (подтверждение оплаты). Никаких очередей.
    Идемпотентно: если ledger уже есть — не начисляем повторно.
    Защита для тестов: если period_start уже заполнен — НЕ перезаписываем.
    """
    meta_json = json.dumps(meta or {}, ensure_ascii=False)

    with get_conn() as conn, conn.cursor() as cur:
        # 1) уже начисляли?
        cur.execute(
            """
            SELECT 1 FROM credits_ledger
            WHERE user_id=%s AND reason='purchase' AND ref_type='payment' AND ref_id=%s
            LIMIT 1
            """,
            (user_id, payment_id),
        )
        if cur.fetchone():
            conn.commit()
            return

        # 2) читаем платеж
        cur.execute(
            """
            SELECT status, paid_at, credits_total, period_start, period_end
            FROM payments
            WHERE id=%s AND user_id=%s
            FOR UPDATE
            """,
            (payment_id, user_id),
        )
        p = cur.fetchone()
        if not p:
            raise HTTPException(404, "payment not found")

        if (p.get("status") or "") != "succeeded":
            conn.commit()
            return

        # ✅ если уже заполнено — не трогаем (чтобы ты мог руками менять для тестов)
        if p.get("period_start") and p.get("period_end") and p.get("credits_total") is not None:
            cur.execute(
                """
                INSERT INTO credits_ledger(user_id, delta, reason, ref_type, ref_id, meta_json)
                VALUES (%s, %s, 'purchase', 'payment', %s, %s::jsonb)
                """,
                (user_id, int(p.get("credits_total") or credits), payment_id, meta_json),
            )
            conn.commit()
            return

        start_ts = paid_at or p.get("paid_at")
        if not start_ts:
            cur.execute("SELECT now() AS n")
            start_ts = cur.fetchone()["n"]

        cur.execute("SELECT (%s::timestamptz + INTERVAL '1 month') AS pe", (start_ts,))
        end_ts = cur.fetchone()["pe"]

        # 3) записываем пакет в payments
        cur.execute(
            """
            UPDATE payments
            SET credits_total=%s,
                credits_remaining=%s,
                period_start=%s,
                period_end=%s
            WHERE id=%s AND user_id=%s
            """,
            (int(credits), int(credits), start_ts, end_ts, payment_id, user_id),
        )

        # 4) ledger
        cur.execute(
            """
            INSERT INTO credits_ledger(user_id, delta, reason, ref_type, ref_id, meta_json)
            VALUES (%s, %s, 'purchase', 'payment', %s, %s::jsonb)
            """,
            (user_id, int(credits), payment_id, meta_json),
        )

        conn.commit()

def credits_get_status(user_id: int) -> Dict[str, Any]:
    """
    TopBar: сумма остатков по ВСЕМ активным пакетам (пересечения разрешены)
    days_left: до ближайшего конца (min period_end)
    """
    q = """
    SELECT
      COALESCE(SUM(credits_remaining), 0) AS credits_remaining,
      MIN(period_end) AS nearest_period_end
    FROM payments
    WHERE user_id = %s
      AND status = 'succeeded'
      AND credits_remaining IS NOT NULL
      AND period_start IS NOT NULL
      AND period_end IS NOT NULL
      AND now() >= period_start
      AND now() <  period_end
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (user_id,))
        row = cur.fetchone() or {}

    total = int(row.get("credits_remaining") or 0)
    pe = row.get("nearest_period_end")

    if not pe:
        return {"credits_remaining": 0, "days_left": 0, "nearest_period_end": None}

    now_ts = datetime.now(pe.tzinfo) if getattr(pe, "tzinfo", None) else datetime.utcnow()
    sec_left = (pe - now_ts).total_seconds()
    days_left = max(0, int(math.ceil(sec_left / 86400.0)))

    return {"credits_remaining": total, "days_left": days_left, "nearest_period_end": pe}


def credits_consume(
    *,
    user_id: int,
    amount: int = 1,
    ref_type: str = "tnved_request",
    ref_id: Optional[int] = None,
    meta: Optional[dict] = None,
) -> int:
    """
    Списываем из активных пакетов по FEFO:
    берём пакет с самым ранним period_end (чтобы меньше сгорало).
    """
    if amount <= 0:
        return credits_get_balance(user_id)

    meta_json = json.dumps(meta or {}, ensure_ascii=False)

    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(
            """
            SELECT id, credits_remaining
            FROM payments
            WHERE user_id=%s
              AND status='succeeded'
              AND credits_remaining IS NOT NULL
              AND period_start IS NOT NULL
              AND period_end IS NOT NULL
              AND now() >= period_start AND now() < period_end
              AND credits_remaining > 0
            ORDER BY period_end ASC
            LIMIT 1
            FOR UPDATE
            """,
            (user_id,),
        )
        pkg = cur.fetchone()
        if not pkg:
            raise HTTPException(402, "Нет активного пакета запросов")

        remaining = int(pkg["credits_remaining"] or 0)
        if remaining < amount:
            raise HTTPException(402, "Недостаточно запросов")

        cur.execute(
            "UPDATE payments SET credits_remaining=%s WHERE id=%s",
            (remaining - amount, int(pkg["id"])),
        )

        cur.execute(
            """
            INSERT INTO credits_ledger(user_id, delta, reason, ref_type, ref_id, meta_json)
            VALUES (%s, %s, 'use', %s, %s, %s::jsonb)
            """,
            (user_id, -amount, ref_type, ref_id, meta_json),
        )

        conn.commit()
        return credits_get_balance(user_id)
    

def credits_get_balance(user_id: int) -> int:
    """Совместимость: сумма остатка активных пакетов."""
    return int(credits_get_status(user_id)["credits_remaining"])
    
def tnved_requests_add(
    *,
    user_id: int,
    query_text: str,
    input_json: dict,
    result_json: dict,
    status: str = "done",
    error_text: Optional[str] = None,
    credits_spent: int = 1,
    model: Optional[str] = None,
    latency_ms: Optional[int] = None,
) -> Dict[str, Any]:
    q = """
    INSERT INTO tnved_requests(user_id, query_text, input_json, result_json, status, error_text,
                              credits_spent, model, latency_ms)
    VALUES (%s, %s, %s::jsonb, %s::jsonb, %s, %s, %s, %s, %s)
    RETURNING *
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(
            q,
            (
                user_id,
                query_text or "",
                json.dumps(input_json or {}, ensure_ascii=False),
                json.dumps(result_json or {}, ensure_ascii=False),
                status,
                (error_text or None),
                int(credits_spent or 1),
                model,
                int(latency_ms) if latency_ms is not None else None,
            ),
        )
        row = cur.fetchone()
        conn.commit()
        return dict(row)


def tnved_requests_list_by_user(user_id: int, limit: int = 200, offset: int = 0) -> List[Dict[str, Any]]:
    q = """
    SELECT *
    FROM tnved_requests
    WHERE user_id = %s
    ORDER BY created_at DESC
    LIMIT %s OFFSET %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (user_id, int(limit), int(offset)))
        return [dict(r) for r in cur.fetchall()]


def payments_list_by_user(user_id: int, limit: int = 200, offset: int = 0) -> List[Dict[str, Any]]:
    q = """
    SELECT
      p.*,
      tp.code  AS tariff_code,
      tp.title AS tariff_title,
      tp.credits AS tariff_credits,
      tp.price_rub AS tariff_price_rub
    FROM payments p
    LEFT JOIN tariff_plans tp ON tp.id = p.tariff_plan_id
    WHERE p.user_id = %s
    ORDER BY p.created_at DESC
    LIMIT %s OFFSET %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (user_id, int(limit), int(offset)))
        return [dict(r) for r in cur.fetchall()]

def set_user_block(user_id: int,*,is_blocked: bool,reason: str = "",blocked_at: Optional[datetime] = None,) -> bool:
    """
    Блок/разблок пользователя.
    Возвращает True если пользователя нашли и обновили, иначе False.
    """
    with get_conn() as conn, conn.cursor() as cur:
        if is_blocked:
            q = """
            UPDATE users
            SET is_blocked = TRUE,
                blocked_reason = %s,
                blocked_at = COALESCE(%s, now())
            WHERE id = %s
            """
            cur.execute(q, (reason or "", blocked_at, int(user_id)))
        else:
            q = """
            UPDATE users
            SET is_blocked = FALSE,
                blocked_reason = NULL,
                blocked_at = NULL
            WHERE id = %s
            """
            cur.execute(q, (int(user_id),))

        updated = (cur.rowcount or 0) > 0
        conn.commit()
        return updated

def credits_ledger_list(user_id: int,*,limit: int = 200,offset: int = 0,) -> List[Dict[str, Any]]:
    """
    История движения кредитов пользователя (ledger).
    Возвращает список записей в порядке от новых к старым.
    """
    limit = max(1, min(int(limit), 1000))
    offset = max(0, int(offset))

    q = """
    SELECT id, user_id, delta, reason, ref_type, ref_id, meta_json, created_at
    FROM credits_ledger
    WHERE user_id = %s
    ORDER BY created_at DESC, id DESC
    LIMIT %s OFFSET %s
    """
    with get_conn() as conn, conn.cursor() as cur:
        cur.execute(q, (int(user_id), limit, offset))
        rows = cur.fetchall() or []
        return [dict(r) for r in rows]
